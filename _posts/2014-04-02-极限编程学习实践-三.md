---
layout: post
title: "极限编程学习实践 三"
description: ""
category: 工作
tags: []
---
{% include JB/setup %}


## 版本控制进阶 ##
----

让持续集成成为可能的一个最重要实践就是每个人每天至少向主干提交一次。

一个更可控的分支策略是：只为发布创建长周期的分支。在这种模式下，新开发的代码总是被提交到主干上。只有在发布分支上修改缺陷时才需要合并，而且这个分支是从分支合并回主干。而只有非常严重的缺陷修复才会从主干合并到发布分支上。这种模式要好一点，因为代码一直处于可发布的状态，所以也就容易发布。分支越少，合并和跟踪分支的工作就越少。



## 集中式管理可能更好 ##
----


虽然理论上用户可以不提交到指定的中央代码库，但这么做根本毫无意义，因为对于持续集成系统来说，不提交代码就不可能做构建。如果将修改的的代码推送给同事而不是推送到中央代码库的话，这种做法带来的麻烦要比带来的价值多得多。

直接将代码从本地代码库推送那个能触发部署流水线的中央代码库之后，才算做了代码集成。频繁提交修改是持续集成的基本实践。为了做持续集成，必须至少每天向中央代码库推送一次修改，理想情况下要更频繁一些。因此，如果DVCS使用不当，以及如何使用基于流的系统做持续集成。

## 主干开发 ##
----

这是一种极其有效的开发方法，也是唯一使你能执行持续集成的方法。

#### 在这种模式下，开发人员几乎总是签入代码到主干，而使用分支的情况极少。主干开发有如下三个好处。

* 确保所有的代码被持续集成。
* 确保开发人员及时获得他人的修改。
* 避免项目后期的“合并地狱”和“集成地狱”。

不好的结果就是：每次向主干签入并不都是可发布状态。

## 按发布分支创建开发 ##
----

在这种模式下，要遵循如下规则：

* 一直在主干上开发新功能。
* 当待发布版本的所有功能都完成了，且希望继续开发新功能时才创建一个分支，
* 当分支上只允许提交那些修复严重缺陷的代码，并且这些修改必须立即合并回主干。
* 当执行时机的发布时，这个分支可以选择性的打一个标签。

## 按功能特性分支 ##
----

这种模式是为了让开发团队更容易再“特性”层次上并行工作，并保持主干的可发布状态。每个用户故事或特性在不同的分支上开发完成。一个故事只有通过测试人员验证无问题后，才会被合并到主干，以确保主干一直是可发布的。

#### 要想让这种模式有效果，就要有如下一些前提条件：

* 每天都要把主干上的所有变更合并到每个分支上。
* 每个特性分支都应该是短生命周期的，理想情况下应该只有几天，绝对不能超过一个迭代周期。
* 活跃分支的数量在任意时刻都应该少于或等于正在开发中的用户故事数量。除非已经把开发的用户故事合并回主干，否则谁都不能创建新分支。
* 在合并回主干之前，该用户故事应该已经由测试人员验收通过了。
* 重构必须即时合并，从而讲合并冲突最小化。
* 技术负责人的一部分职责就是保证主干的可发布状态。

#### 开源项目的一些关键特征使他们更适合这种模式，如下所述。

* 尽管可以有很多人向开源项目做贡献，但仅有一个由经验丰富的开发者组成的相对较小的团队来管理，他们对接受或拒绝补丁有最终的决定权。
* 发布日期相对灵活，这使得开源项目的提交者在拒绝次优的补丁方面有一定的回旋余地。

#### 在大型项目中也能发挥作用，但需要应用下面这些条件：

1. 代码基被合理分解成多个模块；
2. 交付团队被分成几个小团队，每个团队都由一个有经验得开发者领导；
3. 整个团队承诺频繁地向提交主干签入并集成；
4. 交付团队不会屈从于交付压力而导致未达标准的发布决策。



## 按团队分支 ##
----

#### 按团队分支的工作流程：

1. 创建多个小团队，每个团队自己的都由对应的分支。
2. 一旦某个特性或用户故事完成了，就让该分支稳定下来，并合并回主干。
3. 每天都讲主干上的变更合并到每个分支上。
4. 对于每个分支，每次签入后都要运行单元和验收测试。
5. 每次一个分支合并回主干时，在主干上都要运行所有的测试（包括集成测试）


























